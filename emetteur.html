<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>√âmetteur Fast Audio</title>

<style>
body{
  font-family: Arial, sans-serif;
  max-width:820px;
  margin:24px auto;
}

textarea{
  width:100%;
  min-height:120px;
}

button{
  padding:10px 14px;
  font-weight:600;
}

.mono{
  font-family: ui-monospace, monospace;
  white-space: pre-wrap;
  word-break: break-all;
}

.ok{
  color:#0b7a0b;
  font-weight:bold;
}
</style>
</head>

<body>

<h1>üîä √âmetteur FAST BFSK</h1>

<textarea id="texteInput" placeholder="Texte √† envoyer"></textarea>

<br><br>
<button id="sendBtn">Envoyer ultra rapide</button>

<h3>√âtat</h3>
<p id="etat" class="mono">Pr√™t.</p>

<h3>Binaire</h3>
<p id="binaire" class="mono"></p>

<script>

/* ================= CONFIG FAST ================= */

const CFG = {
  BIT_DURATION: 0.03,
  START_DURATION: 0.5,
  END_DURATION: 0.5,
  GAP_DURATION: 0.05,

  FREQ0:1300,
  FREQ1:2600,
  START_FREQ:3400,
  END_FREQ:4200,

  PREAMBLE:"10101010",
  SYNC:"11110000",

  REDUNDANCY:2
};

const audioCtx = new (window.AudioContext||window.webkitAudioContext)();

/* ================= UTILITIES ================= */

function toBits(bytes){
  return Array.from(bytes)
    .map(b=>b.toString(2).padStart(8,'0'))
    .join('');
}

function crc8(bytes){
  let crc=0;

  for(const b of bytes){
    crc ^= b;

    for(let i=0;i<8;i++){
      crc = (crc & 0x80) ? ((crc<<1)^0x07) : (crc<<1);
      crc &= 0xff;
    }
  }

  return crc;
}

function repeatBits(bits,n=CFG.REDUNDANCY){
  if(n<=1) return bits;

  let out="";
  for(let i=0;i<bits.length;i++){
    out+=bits[i].repeat(n);
  }
  return out;
}

/* ================= AUDIO ================= */

function tone(freq,start,dur,gainValue=0.22){

  const osc=audioCtx.createOscillator();
  const gain=audioCtx.createGain();

  osc.frequency.value=freq;
  osc.type="sine";

  gain.gain.setValueAtTime(0.00001,start);
  gain.gain.linearRampToValueAtTime(gainValue,start+0.004);

  gain.gain.setValueAtTime(gainValue,start+dur-0.004);
  gain.gain.linearRampToValueAtTime(0.00001,start+dur);

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start(start);
  osc.stop(start+dur);
}

/* ================= FRAME BUILD ================= */

function buildFrameBits(text){

  const payload=new TextEncoder().encode(text);

  if(payload.length>255)
    throw new Error("Message trop long (max 255 octets)");

  const len=payload.length;
  const crc=crc8(payload);

  const header=
    CFG.PREAMBLE+
    CFG.SYNC+
    len.toString(2).padStart(8,'0');

  const payloadBits=toBits(payload);
  const crcBits=crc.toString(2).padStart(8,'0');

  const frame=header+payloadBits+crcBits;

  return{
    visibleBits:frame,
    encodedBits:repeatBits(frame),
    len,
    crc
  };
}

/* ================= SEND ================= */

async function send(){

  const etat=document.getElementById("etat");
  const binaire=document.getElementById("binaire");
  const text=document.getElementById("texteInput").value;

  if(!text.trim()){
    etat.textContent="‚ö†Ô∏è Entrez un texte.";
    return;
  }

  await audioCtx.resume();

  let frame;

  try{
    frame=buildFrameBits(text);
  }catch(err){
    etat.textContent="‚ùå "+err.message;
    return;
  }

  binaire.textContent=frame.visibleBits;

  let t=audioCtx.currentTime+0.05;

  tone(CFG.START_FREQ,t,CFG.START_DURATION,0.22);
  t+=CFG.START_DURATION+CFG.GAP_DURATION;

  for(const bit of frame.encodedBits){
    tone(
      bit==='0'?CFG.FREQ0:CFG.FREQ1,
      t,
      CFG.BIT_DURATION,
      0.18
    );

    t+=CFG.BIT_DURATION;
  }

  t+=CFG.GAP_DURATION;

  tone(CFG.END_FREQ,t,CFG.END_DURATION,0.22);

  const total=(t+CFG.END_DURATION)-audioCtx.currentTime;

  etat.innerHTML=
    "Transmission lanc√©e<br>"+
    "Dur√©e estim√©e: "+total.toFixed(2)+"s";

  setTimeout(()=>{
    etat.innerHTML+="<br><span class='ok'>Termin√© ‚úÖ</span>";
  },Math.max(0,total*1000));
}

document.getElementById("sendBtn")
.addEventListener("click",send);

</script>
</body>
</html>
